<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown-light.css" />
<style>
.main {
  width: 85%;
  max-width: 600px;
  margin: 50px auto 50px;
}

@media screen and (max-width: 600px) {
  .main {
    width: 85%;
  }
}

.navigation {
  margin-bottom: 50px;
}
.navigation a {
  color: #ff001f;
  text-decoration: underline solid;
  font-family: 'Lucida Console', 'Liberation Mono', Menlo, Monaco, Roboto, apple-system,
    'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
    'WenQuanYi Micro Hei', sans-serif;
}

#homepage,
#homepage body {
  margin: 0;
  padding: 0;
  height: 100%;
}

.homepage-main {
  margin: 0 auto;
  position: relative;
  top: 30%;
  font-weight: normal;
  margin: 0 0 10px;
}

.homepage-title-area {
  transition: opacity 1s;
  margin-bottom: 60px;
}

.homepage-title,
.homepage-subtitle {
  text-align: center;
  font-weight: normal;
  opacity: 0.7;
}

.homepage-title {
  font-size: 30px;
  margin: 0 0 10px;
  font-family: apple-system, 'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC',
    'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;
}

.homepage-subtitle {
  font-size: 12px;
  font-family: 'Lucida Console', 'Liberation Mono', Menlo, Monaco, Roboto, apple-system,
    'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
    'WenQuanYi Micro Hei', sans-serif;
}

.homepage-navigation ul {
  padding: 0;
  text-align: center;
}

.homepage-navigation li {
  list-style: none;
  display: inline-block;
  margin: 30px 0 0 30px;
}
.homepage-navigation li:first-child {
  margin-left: 0;
}

.homepage-navigation a {
  color: #dd4242;
  text-decoration: none;
  font-family: 'Lucida Console', 'Liberation Mono', Menlo, Monaco, Roboto, apple-system,
    'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
    'WenQuanYi Micro Hei', sans-serif;
}
.homepage-navigation a:hover {
  text-decoration: underline;
}

.about p {
  margin-bottom: 30px;
  line-height: 1.5;
}

.about li {
  font-family: 'Lucida Console', 'Liberation Mono', Menlo, Monaco, Roboto, apple-system,
    'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
    'WenQuanYi Micro Hei', sans-serif;
  margin-top: 15px;
}
.about li a {
  color: #000;
  text-decoration: underline solid;
}

.article-title {
  font-weight: normal;
  font-family: apple-system, 'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC',
    'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;
}

.article-info {
  color: #777777;
  margin-bottom: 50px;
  font-family: 'Lucida Console', 'Liberation Mono', Menlo, Monaco, Roboto, apple-system,
    'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
    'WenQuanYi Micro Hei', sans-serif;
}
.article-info span {
  margin: 0 30px 0px 0;
}

.article-info .keyword {
  margin: 5px 5px 0 0;
  display: inline-block;
}

@font-face {
  font-family: octicons-link;
  src: url("https://cdnjs.cloudflare.com/ajax/libs/octicons/4.4.0/font/octicons.woff")
    format('woff');
}

.blogs-list-block {
  line-height: 1.5em;
}
.blogs-list-block ol {
  margin-bottom: 60px;
}
@media screen and (max-width: 600px) {
  .blogs-list-block ol {
    padding-left: 1em;
  }
}
.blogs-list-block li {
  display: flex;
  list-style-type: none;
  margin-bottom: 20px;
}

.annual-block {
  margin-bottom: 50px;
}

.annual-block-headline {
  display: block;
  font-size: 20px;
  margin-bottom: 30px;
  font-family: 'Lucida Console', 'Liberation Mono', Menlo, Monaco, Roboto, apple-system,
    'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
    'WenQuanYi Micro Hei', sans-serif;
}

.annual-block-title {
  font-family: apple-system, 'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC',
    'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;
  color: #000;
  text-decoration: none;
}
.annual-block-title.is-dir {
  text-decoration: dotted underline;
}

.annual-block-date {
  font-family: 'Lucida Console', 'Liberation Mono', Menlo, Monaco, Roboto, apple-system,
    'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
    'WenQuanYi Micro Hei', sans-serif;
  margin-right: 30px;
  color: #999999;
}

.rss-link {
  display: block;
  width: 3em;
  padding-left: 100%;
  margin: 50px 0 100px -3em;
  color: #000;
}

.error {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
}
.error p {
  font-size: 20px;
}
.error a {
  font-family: 'Lucida Console', 'Liberation Mono', Menlo, Monaco, Roboto, apple-system,
    'Helvetica Neue', Arial, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
    'WenQuanYi Micro Hei', sans-serif;
  text-decoration: underline dotted;
  color: #777777;
}

</style>

    <title>
      Benchmarking Context Switching Between P-Cores and E-Cores on Intel CPUs - Abby&#39;s Notes
    </title>
<link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>

<body>
  <div class="main">
    <nav class="navigation">
      <a href="/">
        Abby&#39;s Notes
      </a>
    </nav>
    <article>
      <header>
        <h1 class="article-title">
          Benchmarking Context Switching Between P-Cores and E-Cores on Intel CPUs
        </h1>
        <div class="article-info">
          <div>
            <span>Created At: <time datetime="1714389693882">
                2024-04-29 20:21
              </time></span>
            <span>Updated At: <time datetime="1714392771392">
                2024-04-29 21:12
              </time></span>
          </div>
          
        </div>
      </header>
      <div class="article-content markdown-body"><h1 id="introduction">Introduction</h1>
<p>The latest version of the game Cyberpunk 2077 has successfully implemented a strategy where all its threads are bound to the Performance Cores (P-Cores) of Intel CPUs. This optimization has sparked curiosity from me: why and how?</p>
<p>My hypothesis is that the separation of the L2 cache between E-Cores and P-Cores can introduce significant latency when switching between them. This latency can be particularly slow in certain CPU models, leading to performance degradation. By creating separate thread pools for E-Cores and P-Cores and strategically assigning threads to specific core types, can substantial improve performance.</p>
<p>To investigate this hypothesis and explore the impact of context switching between P-Cores and E-Cores, I developed a benchmark, and will discuss the precautions taken during its development, and analyze the results obtained from running the benchmark on an Intel CPU with both P-Cores and E-Cores.</p>
<h1 id="benchmark-code">Benchmark Code</h1>
<p>The benchmark program is written in C++ and utilizes the Windows API to retrieve processor information and set thread affinity. Here's the code:</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> NUM_ITERATIONS = <span class="hljs-number">1000000</span>;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">benchmarkTask</span><span class="hljs-params">(std::vector&lt;DWORD_PTR&gt; pCoreMasks, std::vector&lt;DWORD_PTR&gt; eCoreMasks, <span class="hljs-type">bool</span> pCoreOnly, <span class="hljs-type">bool</span> eCoreOnly)</span> </span>{
    std::random_device rd;
    <span class="hljs-function">std::mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>;
    std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">pCoreDistribution</span>(<span class="hljs-number">0</span>, pCoreMasks.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
    std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">eCoreDistribution</span>(<span class="hljs-number">0</span>, eCoreMasks.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_ITERATIONS; ++i) {
        <span class="hljs-keyword">if</span> (pCoreOnly &amp;&amp; !pCoreMasks.<span class="hljs-built_in">empty</span>()) {
            <span class="hljs-comment">// Set the thread affinity to a random P-Core</span>
            DWORD_PTR mask = pCoreMasks[<span class="hljs-built_in">pCoreDistribution</span>(gen)];
            <span class="hljs-built_in">SetThreadAffinityMask</span>(<span class="hljs-built_in">GetCurrentThread</span>(), mask);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eCoreOnly &amp;&amp; !eCoreMasks.<span class="hljs-built_in">empty</span>()) {
            <span class="hljs-comment">// Set the thread affinity to a random E-Core</span>
            DWORD_PTR mask = eCoreMasks[<span class="hljs-built_in">eCoreDistribution</span>(gen)];
            <span class="hljs-built_in">SetThreadAffinityMask</span>(<span class="hljs-built_in">GetCurrentThread</span>(), mask);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Randomly select a P-Core or E-Core</span>
            <span class="hljs-type">bool</span> usePCore = (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);

            <span class="hljs-keyword">if</span> (usePCore &amp;&amp; !pCoreMasks.<span class="hljs-built_in">empty</span>()) {
                <span class="hljs-comment">// Set the thread affinity to a random P-Core</span>
                DWORD_PTR mask = pCoreMasks[<span class="hljs-built_in">pCoreDistribution</span>(gen)];
                <span class="hljs-built_in">SetThreadAffinityMask</span>(<span class="hljs-built_in">GetCurrentThread</span>(), mask);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!usePCore &amp;&amp; !eCoreMasks.<span class="hljs-built_in">empty</span>()) {
                <span class="hljs-comment">// Set the thread affinity to a random E-Core</span>
                DWORD_PTR mask = eCoreMasks[<span class="hljs-built_in">eCoreDistribution</span>(gen)];
                <span class="hljs-built_in">SetThreadAffinityMask</span>(<span class="hljs-built_in">GetCurrentThread</span>(), mask);
            }
        }

        <span class="hljs-comment">// Perform some work</span>
        <span class="hljs-type">double</span> result = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; ++j) {
            result += std::<span class="hljs-built_in">sin</span>(j) * std::<span class="hljs-built_in">cos</span>(j);
        }
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>{
    <span class="hljs-type">bool</span> pCoreOnly = <span class="hljs-literal">false</span>;
    <span class="hljs-type">bool</span> eCoreOnly = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// Parse command-line arguments</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) {
        std::string arg = argv[i];
        <span class="hljs-keyword">if</span> (arg == <span class="hljs-string">"--p-core-only"</span>) {
            pCoreOnly = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg == <span class="hljs-string">"--e-core-only"</span>) {
            eCoreOnly = <span class="hljs-literal">true</span>;
        }
    }

    DWORD returnedLength = <span class="hljs-number">0</span>;
    BOOL ret = <span class="hljs-built_in">GetLogicalProcessorInformationEx</span>(RelationProcessorCore, <span class="hljs-literal">nullptr</span>, &amp;returnedLength);
    <span class="hljs-keyword">if</span> (ret == FALSE &amp;&amp; <span class="hljs-built_in">GetLastError</span>() == ERROR_INSUFFICIENT_BUFFER) {
        <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(returnedLength)</span></span>;
        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* processorInfo = <span class="hljs-built_in">reinterpret_cast</span>&lt;SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*&gt;(buffer.<span class="hljs-built_in">data</span>());

        ret = <span class="hljs-built_in">GetLogicalProcessorInformationEx</span>(RelationProcessorCore, processorInfo, &amp;returnedLength);
        <span class="hljs-keyword">if</span> (ret) {
            std::vector&lt;DWORD_PTR&gt; pCoreMasks;
            std::vector&lt;DWORD_PTR&gt; eCoreMasks;

            <span class="hljs-type">char</span>* ptr = buffer.<span class="hljs-built_in">data</span>();
            <span class="hljs-keyword">while</span> (ptr &lt; buffer.<span class="hljs-built_in">data</span>() + returnedLength) {
                SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* info = <span class="hljs-built_in">reinterpret_cast</span>&lt;SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*&gt;(ptr);
                <span class="hljs-keyword">if</span> (info-&gt;Relationship == RelationProcessorCore) {
                    <span class="hljs-keyword">if</span> (info-&gt;Processor.EfficiencyClass == <span class="hljs-number">0</span> || info-&gt;Processor.EfficiencyClass == <span class="hljs-number">2</span>) {
                        pCoreMasks.<span class="hljs-built_in">push_back</span>(info-&gt;Processor.GroupMask[<span class="hljs-number">0</span>].Mask);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info-&gt;Processor.EfficiencyClass == <span class="hljs-number">1</span>) {
                        eCoreMasks.<span class="hljs-built_in">push_back</span>(info-&gt;Processor.GroupMask[<span class="hljs-number">0</span>].Mask);
                    }
                }
                ptr += info-&gt;Size;
            }

            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Number of P-Cores: %zu\n"</span>, pCoreMasks.<span class="hljs-built_in">size</span>());
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Number of E-Cores: %zu\n"</span>, eCoreMasks.<span class="hljs-built_in">size</span>());

            <span class="hljs-comment">// Create multiple benchmark threads</span>
            <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> numThreads = <span class="hljs-number">4</span>;
            std::vector&lt;std::thread&gt; threads;
            <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();

            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i) {
                threads.<span class="hljs-built_in">emplace_back</span>(benchmarkTask, pCoreMasks, eCoreMasks, pCoreOnly, eCoreOnly);
            }

            <span class="hljs-comment">// Wait for all threads to finish</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; thread : threads) {
                thread.<span class="hljs-built_in">join</span>();
            }

            <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
            <span class="hljs-keyword">auto</span> duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start).<span class="hljs-built_in">count</span>();
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Benchmark completed in %lld milliseconds.\n"</span>, duration);
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<h2 id="explanation">Explanation</h2>
<ol>
<li>It retrieves processor information using the <code>GetLogicalProcessorInformationEx</code> function to determine the number of P-Cores and E-Cores available on the system.</li>
<li>It then creates a specified number of benchmark threads (<code>numThreads</code>) and assigns each thread to a <code>benchmarkTask</code> function.</li>
<li>Inside the <code>benchmarkTask</code>, it randomly selects a P-Core or E-Core for each iteration and sets the thread affinity accordingly using SetThreadAffinityMask. The selection is based on command-line flags: <code>--p-core-only</code> for running on P-Cores only, <code>--e-core-only</code> for running on E-Cores only, or no flag for forcing context switching between P-Cores and E-Cores.</li>
<li>Each iteration of the <code>benchmarkTask</code> performs some CPU-intensive work, such as calculating the sum of sine and cosine values.<br />
The program measures the total execution time of the benchmark using <code>std::chrono::high_resolution_clock</code> and displays it in milliseconds.</li>
</ol>
<h1 id="precautions">Precautions</h1>
<p><strong>Core Arrangement</strong>: Initially, the program assumed that P-Cores and E-Cores were arranged in a specific order, which was logically(but not practically) incorrect. It is crucial to retrieve the affinity masks from the processor information using the GetLogicalProcessorInformationEx function and set thread affinity correctly, regardless of the CPU model or core arrangement. This ensures that the benchmark accurately targets different core types and CPU models.</p>
<p><strong>Context Switching Location</strong>: There was a discussion about whether the context switching should happen within the benchmarkTask function or when creating the benchmark threads. It is essential to ensure that the context switching occurs inside the benchmarkTask to accurately measure the impact of switching between P-Cores and E-Cores. Performing context switching outside the task could lead to misleading results.</p>
<h1 id="results">Results</h1>
<p>Running the benchmark program on an Intel CPU with both P-Cores and E-Cores yielded the following results:</p>
<p><strong>P-Core Only</strong>: The benchmark ran the fastest when all threads were bound to P-Cores only.<br />
<strong>E-Core Only</strong>: The benchmark ran slower when all threads were bound to E-Cores only.<br />
<strong>Mixed Mode</strong>: The benchmark exhibited the slowest performance when forcing context switching between P-Cores and E-Cores.</p>
<p>These results align with the hypothesis that the separation of the L2 cache between E-Cores and P-Cores can introduce significant latency when switching between them.</p>
<p>Here is my result on my i7 13700KF CPU (128GB DDR4 3200 Ram, Win 11)</p>
<div><pre class="hljs"><code>.<span class="hljs-string">\bench.exe</span> 
<span class="hljs-built_in">Number</span> <span class="hljs-keyword">of</span> P-Cores: <span class="hljs-number">8</span>
<span class="hljs-built_in">Number</span> <span class="hljs-keyword">of</span> E-Cores: <span class="hljs-number">8</span>
Benchmark completed <span class="hljs-keyword">in</span> <span class="hljs-number">11180</span> milliseconds.
.<span class="hljs-string">\bench.exe</span> --p-core-only
<span class="hljs-built_in">Number</span> <span class="hljs-keyword">of</span> P-Cores: <span class="hljs-number">8</span>
<span class="hljs-built_in">Number</span> <span class="hljs-keyword">of</span> E-Cores: <span class="hljs-number">8</span>
Benchmark completed <span class="hljs-keyword">in</span> <span class="hljs-number">7261</span> milliseconds.
.<span class="hljs-string">\bench.exe</span> --e-core-only
<span class="hljs-built_in">Number</span> <span class="hljs-keyword">of</span> P-Cores: <span class="hljs-number">8</span>
<span class="hljs-built_in">Number</span> <span class="hljs-keyword">of</span> E-Cores: <span class="hljs-number">8</span>
Benchmark completed <span class="hljs-keyword">in</span> <span class="hljs-number">7447</span> milliseconds.</code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>In short, under heavy context switching, P-Core only &gt; E-Core Only &gt; Mixed mode.</p>
<p>I think this may have a even large impact on seperated big.little CPUs like Quadcomm SnapDragon 810.</p>
<p>I hope this experiment serves as a starting point for investigating and optimizing softwares for heterogeneous CPU architectures. By strategically assigning threads to specific core types and minimizing context switching between E-Cores and P-Cores, we potentially improve performance and leverage the full potential of modern desktop/mobile CPUs (even Intel is planned to drop E-Core soon).</p>
<h1 id="appendix">Appendix</h1>
<p>gist: <a title="https://gist.github.com/abbychau/8ac93aa252be9d37b7a69d93e09ab004" href="https://gist.github.com/abbychau/8ac93aa252be9d37b7a69d93e09ab004">https://gist.github.com/abbychau/8ac93aa252be9d37b7a69d93e09ab004</a></p>
<p>main.cpp performance(by multiplying iterations for 100):<br />
<img src="/_resources/64ca3cc703a347cfafb7f8cd1be5ba97.png" /></p>
</div>
    </article>
  </div>
</body>

</html>